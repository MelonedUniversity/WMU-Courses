# Combinatory Logic

组合子逻辑

## 引言

如果你十分惊奇于λ演算的唯常量编程，那么组合子逻辑就更为惊奇了：这玩意居然连常量都不需要依赖即可满足图灵完备性，它是比λ演算更为简洁的编程语言。

## 概要

组合子逻辑是一种符号系统，它可以消除数理逻辑中对变量的需要。组合子（Combinator）在本质上是一系列高阶函数，它捕获了计算本质的很多特征，可看作是λ演算的一种变体。

## $I$ 组合子

$I$ 组合子是最简单的组合子，其定义为：$(I\ x) = x$  
显然，$I$ 组合子的λ表示为 $λx.x$，对于任何输入 $x$，该组合子均返回 $x$

$I$ 组合子被称作恒等组合子。

## $K$ 组合子和 $S$ 组合子

$K$ 组合子：$(K\ x\ y)=x$  
对于组合子$K$，始终得到第一个变量 $x$，因而可用于制造常函数。

$S$ 组合子：$(S\ x\ y\ z)=x\ z\ (y\ z)$  
对于组合子 $S$，它将函数 $x$ 与 $y$ 分别应用到变量 $z$ 上，随后将两个结果进行应用操作。

你可能注意到，$I$ 组合子和 $S$ 组合子和某些λ函数是等价的。是的，不仅它们是等价的，而且这两种组合子具有完备性，即它们的组合可以导出任意类型的λ项。

考虑使用组合子 $S$、$K$ 导出组合子 $I$：  
$((S\ K\ K)\ x)=(S\ K\ K\ x)=(K\ x\ (K\ x))=x$

称 $(S\ K\ K)$ 和 $I$ 是**外延相等**的。

## 使用组合子消除变量依赖$^{*1}$

提出变换 $T[\quad]$，可以转换任意λ项到组合子，定义如下：

1. $T[E]\qquad\qquad⇒E$
2. $T[E_1\ E_2]\qquad\ ⇒T[E_1]\ T[E_2]$
3. $T[λx.E]\qquad\ \ ⇒K\ T[E]$，且 $¬(x→E)$
4. $T[λx.x]\qquad\ \ \ ⇒I$
5. $T[λx.λy.E]\quad\ ⇒T[λx.T[λy.E]]$，且 $x→E$
6. $T[λx.(E_1\ E_2)]\ ⇒S\ T[λx.E_1]\ T[λx.E_2]$

于是，我们尝试转换 $λx.λy.(y\ x)$ 为组合子：

$\quad T[λx.λy.(y\ x)]$  
$=T[λx.T[λy.(y\ x)]]$（通过5）  
$=T[λx.(S\ T[λy.y]\ T[λy.x])]$（通过6）  
$=T[λx.(S\ I\ T[λy.x])]$（通过4）  
$=T[λx.(S\ I\ (K\ x))]$（通过3）  
$=(S\ T[λx.(S\ I)]\ T[λx.(K\ x)])$（通过6）  
$=(S\ (K\ (S\ I))\ T[λx.(K\ x)])$（通过3）  
$=(S\ (K\ (S\ I))\ (S\ T[λx.K]\ T[λx.x]))$（通过6）  
$=(S\ (K\ (S\ I))\ (S\ (K\ K)\ T[λx.x]))$（通过3）  
$=(S\ (K\ (S\ I))\ (S\ (K\ K)\ I))$（通过4）

至此，我们消除了变量依赖。

## Playground

尝试理解以下归约过程：  

$\quad(S\ (K\ (S\ I))\ (S\ (K\ K)\ I)\ x\ y)$  
$=(K\ (S\ I)\ x\ (S\ (K\ K)\ I\ x)\ y)$  
$=(S\ I\ (S\ (K\ K)\ I\ x)\ y)$  
$=(I\ y\ (S\ (K\ K)\ I\ x\ y))$  
$=(y\ (S\ (K\ K)\ I\ x\ y))$  
$=(y\ (K\ K\ x\ (I\ x)\ y))$  
$=(y\ (K\ (I\ x)\ y))$  
$=(y\ (I\ x))$  
$=(y\ x)$

---

### 注解

1. 指一个`量`到`名`的绑定依赖。和λ演算一样，组合子中的量依然是不可变的，「变量依赖」的使用，是约定俗成的缘故。
