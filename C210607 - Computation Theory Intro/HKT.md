# Higher-Kinded Type

高阶类型

## 概要

高阶类型是类型阶数大于一阶的类型的统称，它是一种高度抽象的类型。

## 介绍

我们平常接触到的类型大多都是零阶的，即不需要传入类型参数即可得到具体类型。
例如：

```C++
int x = 1;
```

x是int类型的。

## 类型构造器

类型构造器是指构造类型的一种容器，你需要传入其需要的类型参数以构造出完整的类型。

如果你学过C++，那么你应该了解`vector<T>`，它是一种可变数组，由于该数组存储的数据类型不确定，所以它需要有一个类型参数`T`来指定，例如：

```C++
vector<int> x;
```

`vector`就是一种类型构造器。

在这里我们为类型构造器`vector`传入了一个类型参数`int`，于是得到了具体类型`vector<int>`，所以`vector<T>`就是一阶类型。注意类型的阶数和类型参数无关，假定我们有一个`type<T1,T2>`，那么它仍然是一阶的，只不过是一个二元一阶类型。

那么二阶类型长什么样子？

## 二阶类型

由于C++不支持高阶类型的语法，所以二阶类型不好表示，如果硬要表示的话，他应该长成这个样子（无法通过编译）：

```C++
type<T<_>>
```

等等，这是什么情况？

相信聪明的人已经发现，类型构造器其实也是一种类型，只不过这种类型不完整，需要我们传入类型参数罢了。那么`type<T<_>>`就很好懂了：type的类型参数是一个类型构造器。  
由于`T`是一个类型构造器，那么作为二阶类型的类型参数的前提是它不能被构造完全，如果构造完全，那么就意味着它变成了一个具体类型而不是类型构造器了，所以我们用`T<_>`来表示类型构造器`T`具有一个类型参数，其尚未被构造完全。

## 高阶类型

高阶类型是对大于一阶的类型构造器的统称，所以二阶类型就是一种高阶类型。由于大于二阶的类型太过于抽象，目前编程的抽象水平还远不够，所以我们见到的高阶类型大多都是二阶的。

## 有什么用

人们对编程的抽象追求是无穷尽的。由于用纸带打孔写程序太麻烦，于是我们发明了汇编语言。这还不够，于是就产生了如C语言之类的编程语言，显然面向过程的语言在软件更加复杂的时候还不够用，于是产生了如C++、Java之类的语言......这还不够！于是有了各种设计模式啊、各种架构策略之类的抽象思路。

显然，高阶类型是有用的，只不过你不清楚罢了。

考虑以下Java代码：

```Java
public ArrayList<int> GetIntArrayList()
{
    return new ArrayList<int>();
}
public HashSet<int> GetIntHashSet()
{
    return new HashSet<int>();
}
```

上面的两个方法分别能够返回空的`ArrayList<int>`和`HashSet<int>`对象，但是如果我们需要更多类似于这样的函数，都要求它们能够返回一个包裹`int`的对象，例如`LinkedList<int>`、`TreeSet<int>`......显然我们不能写一一百个这样的不同名方法来支持这一百个不同类型的返回值类型，这太麻烦了，而且代码可读性不见得会很好。

高阶类型能解决这一问题。

```Java
public <T<_>> T<int> GetIntContainer()
{
    return new T<int>();
}
```

现在，你只需要传入类型构造器即可获得相应的对象了：

```Java
var arrayList = GetIntContainer<ArrayList>();//此处借鉴了C#的语法
var linkedList = GetIntContainer<LinkedList>();
var hashList = GetIntContainer<HashSet>();
var treeList = GetIntContainer<TreeSet>();
...
...
```

由于Java也不支持高阶类型，所以上述写法也是行不通的。

当然这里只是举个例子，实际上不用高阶类型也能解决这个问题（例如使用Object放弃类型检查）。但显然高阶类型更为优雅。

实际上，解决代码冗余只不过是高阶类型的副产物罢了，高阶类型是类型安全的，这意味着使用高阶类型的代码能够在编译器被检查出错误，而不是运行期。高阶类型在函数式编程中无处不在，那才是它发挥作用的地方......

## Playground

本节没有作业。
