# Type Inference

类型推导

## 概要

类型推导是编程语言的一种特性，它允许程序员不显示(Explicit)地写出变量的类型而声明变量，这使得程序员省去了不必要的工作，也提升了键盘的使用寿命（大雾）。类型推导是强类型的，因而具有类型安全性，应当注意到其与弱类型的区别。

## 简单的类型推导

许多语言支持类型推导，只是类型推导的程度不同，例如C++11中的`auto`关键字：

```C++
auto x = 1;
```

虽然未指明`x`的类型，但编译器会根据值`1`而自动推导出`x`为`int`类型。

同样的还有Java或C#中的`var`关键字等，这都是最简单的类型推导。类型推导不限于元类型，泛型推导也属于类型推导。

## Kotlin中的增强型类型推导

由于Kotlin借鉴了函数式语言中的许多特性，所以Kotlin具有很强的类型推导能力，下
面是一些例子（并不局限于此！）：

```Kotlin
//例1
fun f(x: Int) = x //返回值类型自动推导，f(x)的返回值类型为Int
```

```Kotlin
//例2
fun <T> f1(): MutableList<T> {
    return mutableListOf<T>()
}
fun <T> f2(): MutableList<T> {
    return f1<T>()//<T>是可以去掉的，在这里被推导了
}
```

另外Java的后向推导也能实现这种功能，但其前向推导是部分功能缺失的（比如你不能用`var x = f1<T>();`这种写法），而C#则缺失了后向推导的部分功能，例2就是C#不能做到的，之所以称Kotlin是增强的，是因为其在前后推导上都很完善。

虽然Kotlin使用了增强型类型推导，但其仍有局限性，例如返回值类型推导不能推导递归函数，如：

```Kotlin
fun fib(x:Int) = if (x>0) { x * fib(x-1) } else { 1 }
```

该计算斐波那契数列函数不能推导出自己的返回值类型。

## 函数式语言中的类型推导

通常，函数式语言具有极强的类型推导能力，甚至强到把显式类型声明作为逻辑约束的存在（类型约束，类似于泛型约束）。你甚至不需要显示声明泛型，这种能力被称作自动泛化：

```Haskell
f g x = g x
```

编译器会自动推导出`g`为函数，而`x`为符合`g`的参数的值，但`g`和`x`具体是什么类型的呢？它们自动泛化的，即所有满足以上特征的`g`和`x`均可被作为f的参数，同时f的返回值类型也被自动推导。

你可能觉得这种类型推导的自由度太高了，如果运用不当，会造成程序错误而无法发现，就像C++中的函数模板或JavaScript中的弱类型一样。其实正是由于强大的类型推导能力，Haskell中的类型错误在编译期就能得到发现，而不是遗留到运行期。

## Playground

今天没有作业。
