# Type Safety

类型安全

## 概要

**类型安全**是编程语言的一种特性，具有类型安全完备的语言不会抛出运行时类型错误，例如空指针异常（Null Pointer Exception,NPE）或者类型转换异常。强大的类型系统往往能够将类型错误在编译期检出，从而避免了将类型错误推迟到运行时。

## 类型安全的反例

* ### 弱类型  

类型安全往往要借助强大的类型系统来实现，而弱类型则根本没有类型的概念（或很模糊），因此不具有类型安全性，考虑以下JavaScript代码：

```JavaScript
function f(a, b) { return a - b }
let x  = f( {} , {} )//NaN
```

由于JavaScript的类型系统是建立在运行期的，所以以上类型错误并不会在编译期（对于JS而言，更确切的表述是运行前）被发现，因而`x`的值在运行期变成了`NaN`，这个错误的值会一直在运行期传播蔓延（期间很可能产生许多不希望的后果！），直到引发异常（Exception）。如果类型系统完备，则在运行前就会发现减法不能作用于`Object`这一事实，因而提前发现了错误。

* ### 滥用继承和多继承

滥用继承是一种为达目的而不择手段的继承方式，出于一些原因，人们有时会在不考虑原有继承关系的情况下进行派生，从而破坏了原有类型的安全性，考虑以下Java代码：

```Java
class A {}//对全局抽象
class B extends A{}//内含业务逻辑
class C extends A{}//内含业务逻辑
```

上述代码由于写的非常好而在社区广受欢迎，所以作者将其做成了一个Java包分享给大家使用。

某公司由于业务面的拓宽，有越来越多的业务逻辑在类`B`和类`C`中呈现高度分化，于是某开发人员小李自己实现了一个类`D`并从`A`中派生出来以满足新的需要（假定小李因为在通宵打代码所以根本没有时间去研究原作者的派生意图）。由于`D`从`A`中派生出来，所以其他的开发人员在需要`A`作为参数的地方传入`D`并不能被编译器检查出来，这就造成了类型安全的缺失。

由于这一原因，Kotlin中的类在默认情况下是封闭（sealed）的，从而在一定程度上缓解了随意派生这种现象。

多继承主要体现在C++中，这种多父类的机制在设计不完备的情况下会出现很大的类型问题（多继承的作用关系往往是难以分析的），因而在现代化的编程语言中往往只允许类的单根继承。

* ### 放弃类型检查

以Java为例，由于其所有类型的基类均为`Object`，所以在迫不得已而使用`Object`的情况下可能会造成类型问题，由于`Object`是Java的**平台类型**（即最终的基类），所以这种类型错误是无法被发现的。

例如：

```Java
Object s = "1";
Object i = 1;
int sum = (int) s + (int) i;//不会被编译器发现
```

虽然例子很⑨，但在实现某些特定功能或模拟一些特性（如泛型或HKT）的时候的确有可能使用上述写法。这用起来很方便，但代价是显而易见的。

强制转换由于放弃了类型检查，因而也难以避免发生错误：

```Java
class Base {}
class Derived extends Base {}

Base    b = new Base();
Derived d = (Derived) b;//不会被编译器发现
```

父类强制转换到子类会造成类型信息的缺失，因而上述代码在运行期抛出了异常。

* ### 封装性破坏  

典型的例子就是C++的友元函数，它破坏了类的封装性，因而对类型安全造成了威胁（因为你可以修改一些数据以使原本能够正常进行的类型转换失败，这是不能被编译器发现的），因而现代化的编程语言均不支持这一特性。

如果推广开来，那么你也能够明白为什么指针不是类型安全的。

* ### 恶臭的NULL

NULL可以说是破坏绝大多数编程语言类型安全的一个罪魁祸首了，以Java为例，几乎所有的引用类型都可以被设置为`null`。因而在某种程度上，`null`是横跨类型系统的一种存在：

```Java
class Clazz{}

String s = null;
Object o = null;
Clazz  c = null;
...//如果大家都为 null，那还有什么类型可言呢？
```

NULL最初是为编程语言的实现的简单性而引入的，而现如今绝大对数的NPE是由NULL引起的，可以说是万恶之源了。

> 我称之为我的十亿美元错误......当时，我正在设计第一个全面的类型系统，用于面向对象语言中的引用功能。我的目标是确保所有对引用的使用都是绝对安全的，由编译器自动执行检查。但是我无法拒绝定义一个 Null 引用的诱惑，因为它实在太容易实现了。这导致了无数错误、漏洞和系统崩溃。在过去的四十年里，这些问题可能已经造成了十亿美元的损失。 ——托尼 · 霍尔

## 类型安全举例

* ### ADT中的类型安全：计数与模式匹配

在ADT那一节的末尾我们提到了ADT具有类型安全性，由于ADT的所有取值是可**计数**$^{*1}$的，因而编译期的类型检查能及时发现类型异常从而使得编译无法被通过。同时，类型安全也为**模式匹配**$^{*2}$这种编程范式提供了安全基础，具有类型安全的类型在模式匹配中也是类型安全的，例如：

```Haskell
data Alphabet = A | B | C

f A = A
f B = B
{-
warning:
  Pattern match(es) are non-exhaustive
  In an equation for ‘f’: Patterns not matched: C
-}
```

由于模式匹配并未匹配完全（缺失了模式`C`），所以这个问题被检测到而产生了警告。类型安全是相对的，显然在绝大多数的工业语言中遗漏匹配并不会得到这样的警告（例如你写的`if`语句并未涵盖所有情况）。

非ADT类型则由于不可计数而使得类型系统难以发现潜在的类型错误。这让我想起了编写RPN那一节时的经历，当时我在为文章末尾讨论的的RPN解析器编写用例：

```Haskell
parser '+' (x : y : s) = (y + x) : s
parser '-' (x : y : s) = (y - x) : s
parser '*' (x : y : s) = (y * x) : s
parser '/' (x : y : s) = (y / x) : s
--parser ' ' s = s
parser x s = (read [x]) : s
```

可见，`parser`的模式匹配拥有相对复杂的类型组合，使得类型系统难以推导其计数（因而计数被忽略了）而发现遗漏的模式。被打上注释的那一行是一个当时被我漏掉的匹配空格的模式，由于类型系统没有检测到这一疏忽，所以我在运行期收到了一个无法匹配空格的异常抛出。

* ### 泛型安全

在没有泛型的情况下，如果我们模拟一个泛型数组，会这样做：

```Java
Object[] intArr = new Object[10];
intArr[0] = 0;
intArr[1] = 1;
intArr[2] = 2;
int i = (int) intArr[2];//取出
```

看起来没什么问题，但这个数组是允许其他类型存入的，这就造成了类型不安全：

```Java
intArr[3] = "3";//不会被编译器发现
int i = (int) intArr[3];//抛出异常
```

而有了泛型，我们就可以这样做：

```Java
var intArr = new ArrayList<Integer>();
intArr.add(1);
intArr.add(2);
intArr.add("3");//不能通过编译
int i = intArr.get(0);
```

编译期类型检查使得其他类型不能添加到泛型数组中，这就使得类型安全得到了保证。与此同时我们还省去了繁琐的类型转换过程。

上述泛型是不变的，泛型型变技术（逆变和协变）允许我们在类型安全的基础上扩展我们的泛型，它同样是类型安全的，这里就不作过多介绍了。同时，高阶类型作为泛型技术的一种扩展，同样享有泛型的类型安全性。

* ### 表达式安全性

表达式也有助于类型安全，考虑以下代码：

```Java
int i;//为了演示而使用int，请考虑可能的NPE情况。
if (...) { i = 1; }
...//TODO
```

如果你写过类似上述的代码，那么你一定了解这样的代码是多么糟糕。如果后续代码用到了`i`的值而你没有在`else`块里规定`i`在另一种情况下的取值，那么很可能引发异常。而在Kotlin中，`if...else...`可以当作表达式来使用，从而避免了因遗忘而导致的未初始化：不同于语句，表达式是必须有返回值的。

```Kotlin
val i: Int = if (...) { 1 } else { 0 }
...//TODO
```

## Playground

今天没有作业。

---

### 注解

1. 计数，即为类型取值的数目。例如布尔类型的取值只有True和False两种，那么我们称其计数为2。如果某个类型的计数过于庞大，那么我们通常认为它是不可计数的。
2. 常见于函数式或具有函数式风格的语言，模式匹配能够在避免使用`if...else...`的同时提供比`switch`强大得多的分支处理能力，模式匹配还具有良好的可读性。
