# Type safety

类型安全

## 概要

**类型安全**是编程语言的一种特性，具有类型安全完备的语言不会抛出运行时类型错误，例如空指针异常（Null Pointer Exception,NPE）或者类型转换异常。强大的类型系统往往能够将类型错误在编译期检出，从而避免了将类型错误推迟到运行时。

## 类型安全的反例

* ### 弱类型  

类型安全往往要借助强大的类型系统来实现，而弱类型则根本没有类型的概念（或很模糊），因此不具有类型安全性，考虑以下JavaScript代码：

```JavaScript
function f(a, b) { return a - b }
let x  = f( {} , {} )//NaN
```

由于JavaScript的类型系统是建立在运行期的，所以以上类型错误并不会在编译期（对于JS而言，更确切的表述是运行前）被发现，因而`x`的值在运行期变成了`NaN`，这个错误的值会一直在运行期传播蔓延（期间很可能产生许多不希望的后果！），直到引发异常（Exception）。如果类型系统完备，则在运行前就会发现减法不能作用于`Object`这一事实，因而提前发现了错误。

* ### 滥用继承和多继承

滥用继承是一种为达目的而不择手段的继承方式，出于一些原因，人们有时会在不考虑原有继承关系的情况下进行派生，从而破坏了原有类型的安全性，考虑以下Java代码：

```Java
class A {}//对全局抽象
class B extends A{}//内涵业务逻辑
class C extends A{}//内涵业务逻辑
```

上述代码由于写的非常好而在社区广受欢迎，所以作者将其做成了一个Java包分享给大家使用。

某公司由于业务面的拓宽，有越来越多的业务逻辑在类`B`和类`C`中呈现高度分化，于是某开发人员小李自己实现了一个类`D`并从`A`中派生出来以满足新的需要（假定小李因为在通宵打代码所以根本没有时间去研究原作者的派生意图）。由于`D`从`A`中派生出来，所以其他的开发人员在需要`A`作为参数的地方传入`D`并不能被编译器检查出来，这就造成了类型安全的缺失。

由于这一原因，Kotlin中的类在默认情况下是封闭（sealed）的，从而在一定程度上缓解了随意派生这种现象。

多继承主要体现在C++中，这种多父类的机制在设计不完备的情况下会出现很大的类型问题（多继承的作用关系往往是难以分析的），因而在现代化的编程语言中往往只允许类的单根继承。

* ### 放弃类型检查

以Java为例，由于其所有类型的基类均为`Object`，所以在迫不得已而使用`Object`的情况下可能会造成类型问题，由于`Object`是Java的**平台类型**（即最终的基类），所以这种类型错误是无法被发现的。

例如：

```Java
Object s = "1";
Object i = 1;
int sum = (int) s + (int) i;//不会被编译器发现
```

虽然例子很⑨，但在实现某些特定功能或模拟一些特性（如泛型或HKT）的时候的确有可能使用上述写法。这用起来很方便，但代价是显而易见的。

强制转换由于放弃了类型检查，因而也难以避免发生错误：

```Java
class Base {}
class Derived extends Base {}

Base    b = new Base();
Derived d = (Derived) b;//不会被编译器发现
```

父类强制转换到子类会造成类型信息的缺失，因而上述代码在运行期抛出了异常。

* ### 封装性破坏  

典型的例子就是C++的友元函数，它破坏了类的封装性，因而对类型安全造成了威胁（因为你可以修改一些数据以使原本能够正常进行的类型转换失败，这是不能被编译器发现的），因而现代化的编程语言均不支持这一特性。

* ### 恶臭的NULL

NULL可以说是破坏绝大多数编程语言类型安全的一个罪魁祸首了，以Java为例，几乎所有的引用类型都可以被设置为`null`。因而在某种程度上，`null`是横跨类型系统的一种存在：

```Java
class Clazz{}

String s = null;
Object o = null;
Clazz  c = null;
...//如果大家都为 null，那还有什么类型可言呢？
```

NULL最初是为编程语言的实现的简单性而引入的，而现如今绝大对数的NPE是由NULL引起的，可以说是万恶之源了。

> 我称之为我的十亿美元错误......当时，我正在设计第一个全面的类型系统，用于面向对象语言中的引用功能。我的目标是确保所有对引用的使用都是绝对安全的，由编译器自动执行检查。但是我无法拒绝定义一个 Null 引用的诱惑，因为它实在太容易实现了。这导致了无数错误、漏洞和系统崩溃。在过去的四十年里，这些问题可能已经造成了十亿美元的损失。 ——托尼 · 霍尔

## 类型安全举例

* ### ADT的类型检查：计数与模式匹配

在ADT那一节的末尾我们提到了ADT具有类型安全性，由于ADT的所有取值是可**计数**的（即取值的可能是有限的，因而能被类型系统检查出来）

* ### 泛型安全和高阶类型

泛型不变与逆变协变

高阶类型安全性

* ### 表达式安全性

表达式也有助于类型安全，考虑以下代码：

```Java

```

```Kotlin

```

## Playground

今天没有作业。
